import os
import pickle
from google.auth.transport.requests import Request
from google_auth_oauthlib.flow import InstalledAppFlow
from googleapiclient.discovery import build
from typing import List, Dict

# スコープ: プレゼンテーションの作成・編集、ドライブへのアクセス（ファイル作成のため）
SCOPES = ['https://www.googleapis.com/auth/presentations', 'https://www.googleapis.com/auth/drive.file']

class GoogleSlideGenerator:
    """
    Google Slides APIを使用してスライドを生成するクラス
    """
    def __init__(self, credentials_path: str = "credentials.json", token_path: str = "token.pickle"):
        self.credentials_path = credentials_path
        self.token_path = token_path
        self.creds = None
        self.service = None
        self.drive_service = None

    def authenticate(self):
        """
        Google APIの認証を行う
        """
        # すでにトークンがあればロード
        if os.path.exists(self.token_path):
            with open(self.token_path, 'rb') as token:
                self.creds = pickle.load(token)

        # トークンがない、または有効期限切れの場合
        if not self.creds or not self.creds.valid:
            if self.creds and self.creds.expired and self.creds.refresh_token:
                try:
                    self.creds.refresh(Request())
                except Exception:
                    # リフレッシュ失敗時は再認証
                    self.creds = None
            
            if not self.creds:
                if not os.path.exists(self.credentials_path):
                    raise FileNotFoundError(f"認証情報ファイルが見つかりません: {self.credentials_path}\nGCPコンソールからダウンロードしてください。")
                
                flow = InstalledAppFlow.from_client_secrets_file(
                    self.credentials_path, SCOPES)
                # ローカルサーバーを立ち上げて認証（ユーザー操作が必要）
                self.creds = flow.run_local_server(port=0)

            # トークンを保存
            with open(self.token_path, 'wb') as token:
                pickle.dump(self.creds, token)

        self.service = build('slides', 'v1', credentials=self.creds)
        self.drive_service = build('drive', 'v3', credentials=self.creds)

    def create_slides(self, title: str, slides_data: List[Dict]) -> str:
        """
        スライドを作成する
        :return: 作成されたスライドのURL
        """
        if not self.service:
            self.authenticate()

        # 1. 新規プレゼンテーション作成
        body = {
            'title': title
        }
        presentation = self.service.presentations().create(body=body).execute()
        presentation_id = presentation.get('presentationId')
        
        # 2. スライドの生成とコンテンツ挿入
        requests = []
        
        # タイトルスライドの削除（デフォルトで1枚あるが、制御しやすくするため一旦消す実装もできるが、
        # ここではデフォルトの1枚目をタイトルスライドとして使う）
        
        # --- 1枚目: 表紙 (Title Slide) ---
        # 既存のスライドIDを取得
        slides = presentation.get('slides')
        title_slide_id = slides[0]['objectId']
        
        # タイトルとサブタイトルをセット
        requests.append({
            'replaceAllText': {
                'containsText': {'text': 'Click to add title', 'matchCase': False}, # テンプレート依存だが標準的
                'replaceText': title
            }
        })
        requests.append({
            'replaceAllText': {
                'containsText': {'text': 'Click to add subtitle', 'matchCase': False},
                'replaceText': 'Generated by AI Summarizer'
            }
        })
        
        # レイアウトIDが必要なため、ページ追加のリクエストを作成
        # 事前にプレゼンテーション情報を取得してLayoutIDを特定するのが確実だが、
        # ここでは標準的な定数IDや挿入ロジックを使用する。
        # 単純化のため: "TITLE_AND_BODY" レイアウトで新しいスライドを追加していく
        
        for i, slide_info in enumerate(slides_data):
            page_id = f"slide_page_{i}"
            
            # スライド追加
            requests.append({
                'createSlide': {
                    'objectId': page_id,
                    'insertionIndex': i + 1,
                    'slideLayoutReference': {
                        'predefinedLayout': 'TITLE_AND_BODY'
                    }
                }
            })
            
            # タイトル設定 (createSlideの直後にplaceholder指定でテキストを入れるのは難しいので、
            # 要素IDを特定するか、追加したスライドに対してShapeを操作する)
            # しかし、APIの仕様上、createSlideで作成されたスライドのPlaceholder IDは予測困難。
            # 汎用的なアプローチ: スライド作成 -> そのスライド内のPlaceholderを取得 -> テキスト設定
            # という2段階が必要だが、batchUpdateは一括実行。
            
            # 簡略化アプローチ: 
            # 1. スライド作成リクエストだけ先に送る
            # 2. GetしてPlaceholder IDを取得
            # 3. テキスト挿入リクエストを送る
            # ↑これをループ内で行うと遅いが確実。
        
        # バッチ実行(スライド作成)
        if len(requests) > 0:
            self.service.presentations().batchUpdate(
                presentationId=presentation_id, 
                body={'requests': requests}
            ).execute()
            requests = [] # クリア

        # 生成されたスライドの詳細を取得して、テキストを埋め込む
        presentation = self.service.presentations().get(presentationId=presentation_id).execute()
        slides = presentation.get('slides')
        
        # 最初のスライド(Title)は除外、追加した分だけ処理
        # slides[0] is Title Slide
        # slides[1...] are added slides
        
        text_requests = []
        
        for i, slide_info in enumerate(slides_data):
            # slides_data[0] corresponds to slides[1] (because slides[0] is title)
            if i + 1 >= len(slides): break
            
            slide_obj = slides[i + 1]
            page_id = slide_obj['objectId']
            
            # Placeholdersを探す
            # 通常、TITLE_AND_BODY では index 0 が Title, index 1 が Body
            title_ph_id = None
            body_ph_id = None
            
            for elem in slide_obj.get('pageElements', []):
                if 'shape' in elem and 'placeholder' in elem['shape']:
                    ph = elem['shape']['placeholder']
                    dtype = ph.get('type')
                    if dtype == 'TITLE' or dtype == 'CENTERED_TITLE':
                        title_ph_id = elem['objectId']
                    elif dtype == 'BODY':
                        body_ph_id = elem['objectId']
            
            # コンテンツ挿入
            if title_ph_id:
                text_requests.append({
                    'insertText': {
                        'objectId': title_ph_id,
                        'text': slide_info.get("title", "No Title")
                    }
                })
            
            if body_ph_id:
                text_requests.append({
                    'insertText': {
                        'objectId': body_ph_id,
                        'text': slide_info.get("content", "")
                    }
                })
                # 箇条書き設定などをここで行うことも可能
                
            # スピーカーノート（Caption + Visual Logic）
            notes_text = slide_info.get("caption", "")
            if "visual_logic" in slide_info:
                notes_text += f"\n\n[図解指示]\n{slide_info['visual_logic']}"
            
            if notes_text:
                # ノートの更新は shape 操作が必要
                # ノートページIDの取得が必要
                notes_page_id = slide_obj.get('slideProperties', {}).get('notesPage', {}).get('objectId')
                # ノートページ内のBODY placeholderを探す必要があるが、API経由でのノート編集は少し複雑。
                # UpdateShapeText を使う。
                # ノートマスタのPlaceholder IDを探す...
                # 簡易実装: insertText to notesPage's BODY placeholder
                pass # ノート編集は実装が複雑なため、Phase 1ではスキップ（余裕があれば実装）
                # メモ: スライド作成時にノートへの書き込みは標準機能として簡単ではないため、
                # 今回は「スライド本文」の充実に注力する。

        if text_requests:
            self.service.presentations().batchUpdate(
                presentationId=presentation_id, 
                body={'requests': text_requests}
            ).execute()

        # URLを生成
        presentation_url = f"https://docs.google.com/presentation/d/{presentation_id}/edit"
        return presentation_url

if __name__ == "__main__":
    # Test
    try:
        gen = GoogleSlideGenerator()
        data = [
            {"title": "テストスライド1", "content": "これはAI生成のテストです。\nGoogle Slides APIを使用しています。"},
            {"title": "機能一覧", "content": "・自動生成\n・クラウド保存\n・共有が簡単"}
        ]
        url = gen.create_slides("APIテストプレゼン", data)
        print(f"Success! URL: {url}")
    except Exception as e:
        print(f"Error: {e}")
